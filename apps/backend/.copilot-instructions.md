# OSM — Backend Agent

## Role

You are the **Backend Agent**. You own `apps/backend` — the Hono + tRPC server that implements all domain logic, JWT authentication, Prisma queries, file uploads, email delivery, and audit logging. You consume Zod schemas from `@osm/api`. You never import from `apps/frontend`.

---

## App Info

```
Framework:    Hono 4.x (HTTP server)
API layer:    tRPC v11 (@trpc/server + @hono/trpc-server)
ORM:          Prisma 5.x → PostgreSQL 16
Auth:         jose 5.x — JWT verification against Okta JWKS endpoint
Email:        Nodemailer or Resend SDK
Runtime:      Node.js 20 LTS
Test:         Vitest
Package:      @osm/backend
Depends on:   @osm/api (Zod schemas + AppRouter type source)
```

---

## Directory Structure

```
apps/backend/
├── src/
│   ├── index.ts              ← Hono app entry point
│   ├── trpc.ts               ← initTRPC, router, protectedProcedure, withPermission
│   ├── context.ts            ← JWT → Context (jose + Okta JWKS)
│   ├── routers/
│   │   ├── index.ts          ← root AppRouter — merges all sub-routers
│   │   ├── auth.ts           ← auth.me, auth.renewToken
│   │   ├── lista.ts          ← lista.all
│   │   ├── security.ts       ← security.myResources
│   │   ├── modelo.ts         ← modelos.*
│   │   ├── perfil.ts         ← perfis.*
│   │   ├── recurso.ts        ← recursos.*
│   │   ├── cliente.ts        ← clientes.*
│   │   ├── faturamento.ts    ← faturamentos.*
│   │   ├── transacao.ts      ← transacoes.*
│   │   ├── processamento.ts  ← processamento.*
│   │   ├── historico.ts      ← historico.*
│   │   ├── showroom.ts       ← showroom.*  (read-only portal)
│   │   ├── categoria.ts      ← categorias.*
│   │   ├── balde.ts          ← baldes.*
│   │   ├── dashboard.ts      ← dashboard.*
│   │   └── admin/
│   │       ├── index.ts      ← admin sub-router (merges users, invitations, etc.)
│   │       ├── users.ts      ← admin.users.*
│   │       ├── invitations.ts← admin.invitations.*
│   │       ├── perfis.ts     ← admin.perfis.* (extended: clone, getUsers, userCount)
│   │       ├── recursos.ts   ← admin.recursos.* (extended: module, perfilCount)
│   │       ├── entities.ts   ← admin.entities.* (generic CRUD for 20 ref types)
│   │       ├── showroom.ts   ← admin.showroom.* (pool + featured management)
│   │       ├── analytics.ts  ← admin.analytics.* (ingest + 6 reports)
│   │       └── auditLog.ts   ← admin.auditLog.*
│   └── lib/
│       ├── prisma.ts         ← Prisma client singleton
│       ├── email.ts          ← sendInvitationEmail(email, token, nome, roles)
│       └── audit.ts          ← writeAuditLog(ctx, action, entityType, entityId, changes)
├── prisma/
│   └── schema.prisma         ← full schema — see PROJECT_INSTRUCTIONS.md §13.6
└── Dockerfile
```

---

## Core Patterns

### Entry point

```typescript
// src/index.ts
import { Hono } from 'hono'
import { trpcServer } from '@hono/trpc-server'
import { cors } from 'hono/cors'
import { appRouter } from './routers/index'
import { createContext } from './context'

const app = new Hono()

app.use('*', cors({
  origin: process.env.FRONTEND_URL ?? 'http://localhost:5173',
  allowHeaders: ['Content-Type', 'Authorization'],
  allowMethods: ['GET', 'POST', 'OPTIONS'],
  credentials: true,
}))

app.use('/trpc/*', trpcServer({ router: appRouter, createContext }))

// File uploads — the only non-tRPC domain endpoints
app.post('/upload/template', async (c) => {
  const body = await c.req.parseBody()
  const file = body['file'] as File
  const modeloId = body['modeloId'] as string
  // store file in S3 or local filesystem
  return c.json({ filename: file.name, size: file.size, url: '...' })
})

app.post('/upload/validate-variables', async (c) => {
  const body = await c.req.parseBody()
  const file = body['file'] as File
  // validate variables and return result
  return c.json({ valid: true, errors: [], variables: [] })
})

app.get('/health', (c) => c.json({ status: 'ok' }))

export default { port: Number(process.env.PORT ?? 3000), fetch: app.fetch }
```

### tRPC setup + withPermission factory

```typescript
// src/trpc.ts
import { initTRPC, TRPCError } from '@trpc/server'
import type { Context } from './context'

const t = initTRPC.context<Context>().create()

export const router = t.router
export const publicProcedure = t.procedure

export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) throw new TRPCError({ code: 'UNAUTHORIZED' })
  return next({ ctx: { ...ctx, userId: ctx.userId } })
})

// Permission-gated procedure — use for every domain data endpoint
export const withPermission = (code: string) =>
  protectedProcedure.use(({ ctx, next }) => {
    if (!ctx.userResources.includes(code))
      throw new TRPCError({ code: 'FORBIDDEN', message: `Missing permission: ${code}` })
    return next()
  })
```

### Context builder (JWT via Okta JWKS)

```typescript
// src/context.ts
import { jwtVerify, createRemoteJWKSet } from 'jose'
import type { FetchCreateContextFnOptions } from '@trpc/server/adapters/fetch'

const JWKS = createRemoteJWKSet(new URL(process.env.IAM_JWKS_URL!))

export interface Context {
  userId: string | null
  userEmail: string | null
  userResources: string[]    // flat list of permission code strings
}

export async function createContext({ req }: FetchCreateContextFnOptions): Promise<Context> {
  const authHeader = req.headers.get('Authorization')
  if (!authHeader?.startsWith('Bearer '))
    return { userId: null, userEmail: null, userResources: [] }
  try {
    const token = authHeader.slice(7)
    const { payload } = await jwtVerify(token, JWKS, {
      issuer: process.env.IAM_ISSUER,
      audience: process.env.IAM_AUDIENCE,
    })
    return {
      userId: payload.sub ?? null,
      userEmail: (payload['email'] as string) ?? null,
      userResources: (payload['resources'] as string[]) ?? [],
    }
  } catch {
    return { userId: null, userEmail: null, userResources: [] }
  }
}
```

### Router scaffold pattern

```typescript
// src/routers/modelo.ts
import { z } from 'zod'
import { router, withPermission } from '../trpc'
import { ModeloDtoSchema, FiltroModeloDashboardSchema } from '@osm/api'
import { prisma } from '../lib/prisma'

export const modeloRouter = router({
  list: withPermission('TELA_CONSULTA_MODELO')
    .input(z.object({
      page: z.number().int().min(0).default(0),
      size: z.number().int().min(1).max(100).default(20),
      sort: z.string().optional(),
      filter: FiltroModeloDashboardSchema.optional(),
    }))
    .query(async ({ input }) => {
      const { page, size } = input
      const [content, totalElements] = await Promise.all([
        prisma.modelo.findMany({ skip: page * size, take: size, include: { status: true, tipoProduto: true } }),
        prisma.modelo.count(),
      ])
      return {
        content, totalElements,
        totalPages: Math.ceil(totalElements / size),
        size, number: page,
        numberOfElements: content.length,
        first: page === 0,
        last: (page + 1) * size >= totalElements,
        empty: content.length === 0,
      }
    }),

  getById: withPermission('TELA_CONSULTA_MODELO')
    .input(z.object({ id: z.string() }))
    .query(async ({ input }) => {
      const modelo = await prisma.modelo.findUnique({
        where: { id: input.id },
        include: { status: true, tipoProduto: true, cliente: true, /* ... */ },
      })
      if (!modelo) throw new TRPCError({ code: 'NOT_FOUND' })
      return modelo
    }),
})
```

### Audit log writer

```typescript
// src/lib/audit.ts
import { prisma } from './prisma'
import type { Context } from '../context'

interface AuditParams {
  ctx: Context & { userId: string }
  action: string               // e.g. 'UPDATE_USER_STATUS', 'CREATE_PERFIL'
  entityType: string           // e.g. 'User', 'Modelo', 'ShowroomFeatured'
  entityId: string
  entityLabel: string          // human-readable, e.g. model name or user email
  changes?: { field: string; oldValue: unknown; newValue: unknown }[]
  metadata?: Record<string, unknown>
}

export async function writeAuditLog(params: AuditParams): Promise<void> {
  await prisma.auditLog.create({
    data: {
      userId: params.ctx.userId,
      userEmail: params.ctx.userEmail ?? '',
      action: params.action,
      entityType: params.entityType,
      entityId: params.entityId,
      changes: params.changes ?? [],
      metadata: params.metadata ?? null,
    },
  })
}

// Usage in an admin mutation:
// await writeAuditLog({ ctx, action: 'UPDATE_USER_STATUS', entityType: 'User',
//   entityId: user.id, entityLabel: user.email,
//   changes: [{ field: 'isActive', oldValue: true, newValue: false }] })
```

### Prisma singleton

```typescript
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as { prisma: PrismaClient }
export const prisma = globalForPrisma.prisma ?? new PrismaClient()
if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

---

## Test Pattern (Vitest)

```typescript
// src/routers/modelo.spec.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { createCaller } from '@trpc/server'
import { appRouter } from './index'

const mockCtx = {
  userId: 'user-1',
  userEmail: 'test@example.com',
  userResources: ['TELA_CONSULTA_MODELO'],
}

const caller = createCaller(appRouter)(mockCtx)

describe('modelos.list', () => {
  it('returns paginated list', async () => {
    const result = await caller.modelos.list({ page: 0, size: 20 })
    expect(result.content).toBeInstanceOf(Array)
    expect(result.totalElements).toBeGreaterThanOrEqual(0)
  })

  it('throws FORBIDDEN when permission missing', async () => {
    const ctxNoPerms = { ...mockCtx, userResources: [] }
    const callerNoPerms = createCaller(appRouter)(ctxNoPerms)
    await expect(callerNoPerms.modelos.list({ page: 0, size: 20 }))
      .rejects.toMatchObject({ code: 'FORBIDDEN' })
  })
})
```

---

## Domain-Specific Rules

1. **Portuguese field names** — Prisma models use the English schema names but router inputs/outputs match the Portuguese TypeScript interfaces in `PROJECT_INSTRUCTIONS.md §6` exactly
2. **Audit log is mandatory** for every mutation under `admin.*` — call `writeAuditLog()` after every successful admin write
3. **Generic entity CRUD** — the 20 reference types (`StatusModelo`, `TipoProduto`, etc.) all go through `admin.entities.*` with the `EntityType` discriminator from `@osm/api`
4. **Soft-delete only** — reference entities are never hard-deleted; set `isActive: false`
5. **Error codes:**
   - `UNAUTHORIZED` — no valid JWT
   - `FORBIDDEN` — valid JWT but missing permission
   - `NOT_FOUND` — entity does not exist
   - `BAD_REQUEST` — Zod validation failure or business rule violation
   - `UNPROCESSABLE_CONTENT` — business constraint (e.g. `maxFeatured` exceeded, role has active users)
